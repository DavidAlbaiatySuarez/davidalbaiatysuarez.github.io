package DynamicSet;

/**
 * Class representing nodes in our Doubly Linked List (DLL)
 * 
 * @author 2474364A
 *
 */
class NodeDLL { 
    
	NodeDLL previousNode, nextNode;
	int key; 
	
    public NodeDLL(int value){ 
        this.key = value; 
        this.previousNode = null;
        this.nextNode = null; 
    } 
}

/**
 * Doubly linked list implementation (DLL) containing the following operations and set-theoretical operations:
 * 		add(), remove(), isElement(), setEmpty(), setSize(), union(), intersection(), difference(), subset()
 * 				
 * @author 2474364A
 *
 */
public class DLL {
	
	/** head field initialized to null */
	private NodeDLL head = null;
	/** tail field initialized to null */
	private NodeDLL tail = null;
	
	
	/**
	 * Inserts a new node z AT THE END of the doubly linked list
	 * Overall, O(n) since we need to check if the key provided is already in the DLL.
	 * The adding operation is O(1) - performed in constant time - since we do not traverse the doubly linked list
	 * @param s (doubly linked list)
	 * @param z (element of type int)
	 */
	public void add(int z) {
		// If key z already in the DLL terminate method since our implementation CANNOT contain duplicates
		if(isElement(z)) {
			return;
		}
		
		NodeDLL tempNode = new NodeDLL(z);
		
		// If we have an empty DLL
		if(head == null) {
			head = tempNode;
			tail = tempNode;
			tail.nextNode = null;
			head.previousNode = null;
		// DLL not empty
		}else {
			tail.nextNode = tempNode;
			tempNode.previousNode = tail;
			tail = tempNode;
			tail.nextNode = null;
		}
		
	}
	
	/**
	 * Removes a given key from a Doubly Linked List (based on the implementation from lecture)
	 * Overall, O(n) since we need to traverse the DLL to find the node that has the value of the given key (z)
	 * @param s (doubly linked list)
	 * @param z (element of type int)
	 */
	public void remove(int key) {
		NodeDLL current = head;
		
		// Empty doubly linked list (exit method)
		if(head == null) return;
		
		while(current != null) {
			// Element found return true
			if(current.key == key) {
				remove(current);
				return;
			}
			current = current.nextNode;
		}
		// Element not found return undefined
		return;
	}
	/**
	 * O(1) - performed in constant time - since we do not need to traverse the doubly linked list (Pseudocode implementation from Lecture)
	 */
	private void remove(NodeDLL z) {
		
		// Case where we do not have the first node
		if(z.previousNode != null) z.previousNode.nextNode = z.nextNode;
		else this.head = z.nextNode;
		
		// Case where we do not have the last node
		if(z.nextNode != null) z.nextNode.previousNode = z.previousNode;
		
	}
	
	/**
	 * Search if element x in the Doubly Linked List (iteratively) 
	 * O(n)
	 * @param s
	 * @param x
	 */
	public boolean isElement(int x) {
		
		NodeDLL current = head;
		
		// Empty doubly linked list (exit method)
		if(head == null) return false;
		
		while(current != null) {
			// Element found return true
			if(current.key == x) return true;
			current = current.nextNode;
		}
		
		// Element not found return false
		return false;
	}
	
	/**
	 * checks whether the doubly linked list s has no elements
	 * O(1)
	 * @param s
	 * @return
	 */
	public boolean setEmpty() {
		if(this.head == null) return true;
		else return false;
	}
	
	/**
	 * returns the number of elements of set S
	 * O(n) since we iterate the whole doubly linked list
	 * @param s (doubly linked list)
	 * @return
	 */
	public int setSize() {
		return setSize(this.head);
	}
	private int setSize(NodeDLL z) {
		int size = 0;
		if(z == null) return 0;
		
		while(z != null) {
			z = z.nextNode;
			size++;
		}
		return size;
	}
	
	/**
	 * Returns the union of two doubly linked lists
	 * O(n^2) since we have O(n*m) where m = size of DLL s and n = size of DLL t
	 * @param s (DLL)
	 * @param t (DLL)
	 * @return a new DLL containing the union of s and t
	 */
	public static final DLL union(DLL s, DLL t) {
		NodeDLL tempS = s.head;
		NodeDLL tempT = t.head;
		
		DLL temp = new DLL();
		
		// We first insert all keys from the first DLL (s) into a new DLL
		while(tempS != null) {
			temp.add(tempS.key);
			tempS = tempS.nextNode;
		}
		
		// We then insert all non-repeating elements of the second DLL (t) into the new DLL
		while(tempT != null) {
			if(!(temp.isElement(tempT.key))) temp.add(tempT.key);
			tempT = tempT.nextNode;
		}
		
		return temp;
	}
	
	/**
	 * Returns the intersection of two doubly linked list
	 * O(n^2) since we have O(m*n) where m = size of DLL s and n = size of DLL t
	 * @param s (DLL)
	 * @param t (DLL)
	 * @return a new DLL containing the intersection of s and t
	 */
	public static final DLL intersection(DLL s, DLL t) {
		NodeDLL tempS = s.head;
		DLL temp = new DLL();
		
		// traverse the DLL s and see if there are elements present in DLL t
		while(tempS != null) {
			if(t.isElement(tempS.key)) temp.add(tempS.key);
			tempS = tempS.nextNode;
		}
		
		return temp;
	}
	
	/**
	 * Returns the difference of two doubly linked list (all elements in DLL s not present in DLL t)
	 * O(n^2) since we have O(m*n) where m = size of DLL s and n = size of DLL t
	 * @param s (DLL)
	 * @param t (DLL)
	 * @return a new DLL containing the difference of s and t
	 */
	public static final DLL difference(DLL s, DLL t) {
		NodeDLL tempS = s.head;
		DLL temp = new DLL();
		
		// traverse the DLL s and compare the elements with the DLL t
		while(tempS != null) {
			if(!(t.isElement(tempS.key))) temp.add(tempS.key);
			tempS = tempS.nextNode;
		}
		
		return temp;
	}
	
	/**
	 * Helper method to find if array B is a subset of array A
	 * O(n)
	 * @param B (array)
	 * @param A (array)
	 * @param m (int - length of array B)
	 * @param n (int - length of array A)
	 * @return true or false
	 */
	private static final boolean isSubarray(int B[], int A[],  int m, int n) { 
        // We will traverse each array simultaneously (using pointers)
        int i = 0, j = 0; 
      
        while(i < n && j < m) { 
            if(A[i] == B[j]) { 
                i++; 
                j++; 
                // If array B has all elements in arrayA
                if (j == m) return true; 
            }else{ 
            	j = 0; 
                i++; 
            } 
        }
        // Array A is not a sub array of Array B
        return false; 
    } 
	
	/**
	 * Helper method that converts a doubly linked list into an array
	 * O(n)
	 * @param z (DLL)
	 * @return new array of type int[]
	 */
	private static final int[] arrayConverter(DLL z) {
		NodeDLL currentNode = z.head;
		int[] temp = new int[z.setSize()];
		int i = 0;
		
		while(currentNode != null) {
			temp[i] = currentNode.key;
			i++;
			currentNode = currentNode.nextNode;
		}
		
		return temp;
	}
	
	/**
	 * Checks if DLL s is a subset of DLL t
	 * O(n)
	 * @param s (DLL)
	 * @param t (DLL)
	 * @return true (if subset) or false otherwise
	 */
	public static final boolean subset(DLL s, DLL t) {
		int[] tempS = arrayConverter(s);
		int[] tempT = arrayConverter(t);
		
		return isSubarray(tempS, tempT, tempS.length, tempT.length);
	}
	
	public void print() {
		NodeDLL current = head;
		
		if (head == null) System.out.println("DLL empty");
		else {
			while (current != null) {
				System.out.print(current.key + ", ");
				current = current.nextNode;
			}
		}
	}
}






