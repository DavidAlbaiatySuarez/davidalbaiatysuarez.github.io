package DynamicSet;

class NodeDLL { 
    
	NodeDLL previousNode, nextNode;
	int key; 
	
    public NodeDLL(int value){ 
        this.key = value; 
        this.previousNode = null;
        this.nextNode = null; 
    } 
}

public class DLL {
	
	/** head field initialized to null */
	private NodeDLL head = null;
	/** tail field initialized to null */
	private NodeDLL tail = null;
	
	
	/**
	 * Inserts a new node z into an appropriate position in doubly linked list s
	 * O(1) - performed in constant time - since we do not traverse the doubly linked list
	 * @param s (doubly linked list)
	 * @param z (element of type int)
	 */
	public void add(DLL s, int z) {
		
		NodeDLL tempNode = new NodeDLL(z);
		
		// If we have an empty list
		if(head == null) {
			head = tempNode;
			tail = tempNode;
			tail.nextNode = null;
			head.previousNode = null;
		}else {
			tail.nextNode = tempNode;
			tempNode.previousNode = tail;
			tail = tempNode;
			tail.nextNode = null;
		}
		
	}
	
	/**
	 * Removes a given node from the Doubly Linked List (based on the implementation from lecture)
	 * O(1) - performed in constant time - since we do not need to traverse the doubly linked list
	 * @param s (doubly linked list)
	 * @param z (element of type int)
	 */
	public void remove(DLL s, NodeDLL z) {
		//NodeDLL nodeToRemove = new NodeDLL(z);
		
		// Case where we do not have the first node
		if(z.previousNode != null) z.previousNode.nextNode = z.nextNode;
		else head = z.nextNode;
		
		// Case where we do not have the last node
		if(z.nextNode != null) z.nextNode.previousNode = z.previousNode;
	}
	
	/**
	 * Search if element x in the Doubly Linked List (iteratively) 
	 * O(n)
	 * @param s
	 * @param x
	 */
	public boolean isElement(DLL s, int x) {
		
		NodeDLL current = head;
		
		// Empty doubly linked list (exit method)
		if(head == null) return false;
		
		while(current != null) {
			// Element found return true
			if(current.key == x) return true;
			current = current.nextNode;
		}
		
		// Element not found return false
		return false;
	}
	
	/**
	 * checks whether the doubly linked list s has no elements
	 * O(1)
	 * @param s
	 * @return
	 */
	public boolean setEmpty(DLL s) {
		if(s.head == null) return true;
		else return false;
	}
	
	/**
	 * returns the number of elements of set S
	 * O(n) since we iterate the whole doubly linked list
	 * @param s (doubly linked list)
	 * @return
	 */
	public int setSize(DLL s) {
		return setSize(s.head);
	}
	private int setSize(NodeDLL z) {
		int size = 0;
		if(z == null) return 0;
		
		while(z != null) {
			z = z.nextNode;
			size++;
		}
		return size;
	}
	
	/**
	 * Returns the union of two doubly linked lists
	 * O(n^2) since we have O(n*m)
	 * @param s (DLL)
	 * @param t (DLL)
	 * @return a new DLL containing the union of s and t
	 */
	public DLL union(DLL s, DLL t) {
		NodeDLL tempS = s.head;
		NodeDLL tempT = t.head;
		
		DLL temp = new DLL();
		
		// We first insert all keys from the first DLL (s) into a new DLL
		while(tempS != null) {
			temp.add(temp, tempS.key);
			tempS = tempS.nextNode;
		}
		
		// We then insert all non-repeating elements of the second DLL (t) into the new DLL
		while(tempT != null) {
			if(!(temp.isElement(temp, tempT.key))) temp.add(temp, tempT.key);
			tempT = tempT.nextNode;
		}
		
		return temp;
	}
	
	public void intersection(DLL s, DLL t) {
		NodeDLL tempS = s.head;
		NodeDLL tempT = t.head;
		
		DLL temp = new DLL();
		
		// traverse the DLL s and see if there are elements present in DLL t
		while(tempS != null) {
			if(t.isElement(t, tempS.key)) temp.add(temp, tempS.key);
			tempS = tempS.nextNode;
		}
		
		return temp;
		
		
	}
	
	public void difference(DLL s, DLL t) {
		// TODO
	}
	
	public void subset(DLL s, DLL t) {
		// TODO
	}
	
	
	
	
	public void print() {
		NodeDLL current = head;
		
		if (head == null) System.out.println("DLL empty");
		else {
			while (current != null) {
				System.out.print(current.key + ", ");
				current = current.nextNode;
			}
		}
	}
	
	public static void main(String[] args) {
		DLL list1 = new DLL();
		DLL list2 = new DLL();
		
		//NodeDLL node1 = new NodeDLL(10);
		//NodeDLL node2 = new NodeDLL(20);
		//NodeDLL node4 = new NodeDLL(40);
		//NodeDLL node3 = new NodeDLL(30);
		//NodeDLL node5 = new NodeDLL(50);
		
		list1.add(list1, 10);
		list1.add(list1, 30);
		list1.add(list1, 40);
		list1.add(list1, 20);
		list1.add(list1, 50);
		
		list1.print();
		System.out.println();
		System.out.println(list1.setSize(list1));
		//list1.remove(list1, node1);
		
		System.out.println();
		list1.print();
		System.out.println();
		System.out.println(list1.isElement(list1, 10)); // Expected return: false
		
		System.out.println(list1.setSize(list1));
		
		list2.add(list2, 20);
		list2.add(list2, 50);
		list2.add(list2, 70);
		list2.add(list2, 5);
		list2.add(list2, 100);
		
		
		
		System.out.println();
		DLL temp = list1.union(list1, list2);
		temp.print();
		
	}
	
	
	
}






