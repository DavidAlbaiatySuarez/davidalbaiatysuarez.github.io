package DynamicSet;

import java.util.Arrays;

/**
 * Class representing nodes in our Binary Search Tree (BST)
 * 
 * @author 2474364A
 *
 */
class Node { 
    
	Node left, right;
	int key; 
	
    public Node(int value){ 
        this.key = value; 
        this.left = null;
        this.right = null; 
    } 
}

/**
 * Binary Search Tree (BST) implementation containing the following operations and set-theoretical operations:
 * 		add(), remove(), isElement(), setEmpty(), setSize(), union(), intersection(), difference(), subset()
 * 
 * @author 2474364A
 *
 */
public class BST {
	
	/** unique boolean field (for difference method) */
	private boolean unique = true;
	
	/** root of type Node field*/
	// Initially, root is null since tree is empty!
	private Node root = null;
	
	/**
	 * Inserts a new node z into an appropriate position in tree t
	 * O(n) since we need to check if the value is in the binary search tree
	 * @param t (tree)
	 * @param z (the new node to be inserted)
	 */
	public void add(int x) {
		// If x is NOT in the BST call the add method, else terminate
		if(!(isElement(x))) this.root = add(root, x);
	}
	private Node add(Node root, int x) {
		// Case 1: empty tree (the first element added is the root)
		if(root == null) {
			root = new Node(x);
			return root;
		}
		// Case 2: root.key < x (traverse and insert node right subtree)
		if(root.key < x) root.right = add(root.right, x);
		// Case 3: root.ley > x (traverse and insert node left subtree)
		else if(root.key > x) root.left = add(root.left, x);
		
		// return root when node inserted in correct position
		return root;
		
	}
	
	/**
	 * removes a given node from the BST
	 * O(n) in the worst case - in general, O(h) where h is the height of the tree
	 * @param t
	 * @param z
	 * @return
	 */
	public Node remove(Node z) {
		
		Node parent = null;
		Node current = this.root;
		
		while(current != null && current.key != z.key) {
			parent = current;
			if(z.key < current.key) current = current.left;
			else current = current.right;
		}
		
		if(current == null) return this.root;
		
		// First case: node has no children
		if(current.left == null && current.right == null) {
			if(current!=this.root) {
				if(parent.left == current) parent.left = null;
				else parent.right = null;
			}else root=null;
		}
		// Second case: node has two children
		else if(current.left !=null && current.right != null) {
			while(current.right.left != null) {
				current.right = current.left;
			}
			
			int val = current.right.key;
			remove(current.right);
			current.key = val;
		}
		// Third case: node has one child
		else {
			Node child;
			if(current.left != null) child = current.left;
			else child = current.right;
			
			if (current != root) {
				if (current == parent.left) parent.left = child;
				else parent.right = child;
			}else this.root = child;
		}
		
		return this.root;
	}
	
	/**
	 * Search if element x in BST (iteratively)
	 * O(n) in the worst case - in general, O(h) where h is the height of the tree
	 * @param x (root of the tree)
	 * @param k (key)
	 * @return
	 */
	public boolean isElement(int k){
		Node x = this.root;
		
		while(!(x==null) && !(k==x.key)) {
			if(k < x.key) x = x.left;
			else x = x.right;
		}
		return (!(x == null));    
	}
	
	/**
	 * checks whether the tree s has no elements
	 * O(1)
	 * @param s 
	 * @return true if empty, false otherwise
	 */
	public boolean setEmpty() {
		if(this.root == null) return true;
		else return false;
	}
	
	/**
	 * returns the number of elements of set S
	 * O(n)
	 * @param s (tree)
	 * @return element of type int
	 */
	public final int setSize() {
		return setSize(this.root);
	}
	private final int setSize(Node t) {
		if(t == null) return 0;
		else return setSize(t.left) + 1 + setSize(t.right);
	}
	
	/**
	 * Creates an array containing the keys (inOrder) of all the nodes in the BST
	 * O(n)
	 */
	public int[] inOrderArrayTraversal(int[] nodes) {
		inOrderArrayTraversal(root, nodes, 0);
		return nodes;
	}
	private int inOrderArrayTraversal(Node root, int[] nodes, int curIndex) { 
	    if (root == null) return curIndex;
	    else { 
	    	curIndex = inOrderArrayTraversal(root.left, nodes, curIndex); 
	        nodes[curIndex++] = root.key;
	        curIndex = inOrderArrayTraversal(root.right, nodes, curIndex);
	        return curIndex;
	    } 
	} 
	
	/**
	 * returns the union of sets S and T
	 * O(n)
	 * @param t (tree 1)
	 * @param s (tree 2)
	 */
	public void union(BST t, BST s) {
		BST x = new BST();
		
		int[] arrayT = new int[t.setSize(t)];
		t.inOrderArrayTraversal(arrayT);
		int[] arrayS = new int[s.setSize(s)];
		s.inOrderArrayTraversal(arrayS);
		
		for(int i : arrayT) x.add(i);
		for(int j : arrayS) x.add(j);
		
		int[] temp = new int[t.setSize(t) + s.setSize(s)];
		System.out.println(Arrays.toString(x.inOrderArrayTraversal(temp)));
	}
	
	
	/**
	 * returns the union of two binary search trees
	 * O(k^2) – O(m*n) where m and n are the size of the two BST’s
	 * @param t (tree 1)
	 * @param s (tree 2)
	 */
	public void intersection(BST t, BST s) {
	    BST x = new BST();
		
		int[] arrayT = new int[t.setSize(t)];
		t.inOrderArrayTraversal(arrayT);
		int[] arrayS = new int[s.setSize(s)];
		s.inOrderArrayTraversal(arrayS);
		
		for(int i : arrayT) {
			for(int j : arrayS) {
				if(i == j) x.add(i);
			}
		}
		
		int[] temp = new int[x.setSize(x)];
		
		System.out.println(Arrays.toString(x.inOrderArrayTraversal(temp)));
	}
	
	/**
	 * returns the difference of two binary search trees
	 * (set of nodes in s not present in t)
	 * O(k^2) – O(m*n) where m and n are the size of the two BST’s
	 * @param t (tree 1)
	 * @param s (tree 2)
	 */
	public void difference(BST s, BST t) {
		BST x = new BST();
		
		int[] arrayT = new int[t.setSize(t)];
		t.inOrderArrayTraversal(arrayT);
		int[] arrayS = new int[s.setSize(s)];
		s.inOrderArrayTraversal(arrayS);
		
		
		for(int i : arrayT) {
			for(int j : arrayS) {
				if(i == j) unique = false;
			}
			if(unique==true) x.add(i);
		}
		
		int[] temp = new int[x.setSize(x)];
		System.out.println(Arrays.toString(x.inOrderArrayTraversal(temp)));
		
	}
	
	/**
	 * Helper method to find if array A is a sub-array of array B
	 * @param A (array - check if sub-array)
	 * @param B (array)
	 * @param n (length of array A)
	 * @param m (length of array B)
	 * @return
	 */
    private boolean isSubarray(int A[], int B[],  int n, int m) { 
        // Two pointers to traverse each respective array
        int i = 0, j = 0; 
      
        while (i < n && j < m) { 
            if (A[i] == B[j]) { 
                i++; 
                j++; 
                // If array B has all elements in arrayA
                if (j == m) return true; 
            } else{ 
            	j = 0; 
            	i++;
            } 
        }
        // Array A is not a sub array of Array B
        return false; 
    } 
    
	/**
	 * checks whether a binary search tree is a subset of another binary search tree
	 * O(n)
	 * @param s (tree 1)
	 * @param t (tree 2)
	 */
	public boolean subset(BST s, BST t) {
		int[] arrayT = new int[t.setSize(t)];
		t.inOrderArrayTraversal(arrayT);
		int[] arrayS = new int[s.setSize(s)];
		s.inOrderArrayTraversal(arrayS);
		
		return isSubarray(arrayT, arrayS, arrayT.length, arrayS.length);
	}
	
	
	
	
	
	public static void main(String[] args) {
		
		/*
		BST t = new BST();
		t.add(t, new Node(45));
        t.add(t, new Node(10)); 
        t.add(t, new Node(7)); 
        t.add(t, new Node(12)); 
        t.add(t, new Node(90)); 
        t.add(t, new Node(50));
        */
		BST t = new BST();
		
		t.add(12);
        t.add(4); 
        t.add(6); 
        t.add(30);
        
        int[] array = new int[t.setSize(t)];
        
        System.out.println(Arrays.toString(t.inOrderArrayTraversal(array)));
        
        //t.remove(t, a);
        
        BST s = new BST();
        s.add(50);
        s.add(30);
        s.add(20);
        s.add(40);
        s.add(70);
        s.add(60);
        s.add(12);
        
        array = new int[s.setSize(s)];
        System.out.println(Arrays.toString(s.inOrderArrayTraversal(array)));
        System.out.println();
        
        t.union(t, s);
        System.out.println();
        t.intersection(t, s);
        System.out.println();
        t.difference(s, t);
        System.out.println();
        System.out.println(t.subset(t,s));
        System.out.println();
	}
	
	
}
