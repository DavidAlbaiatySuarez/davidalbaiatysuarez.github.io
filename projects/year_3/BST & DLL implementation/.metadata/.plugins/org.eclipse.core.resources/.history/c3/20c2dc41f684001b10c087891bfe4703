package DynamicSet;

class Node { 
    
	Node left, right;
	int key; 
	
    public Node(int value){ 
        this.key = value; 
        this.left = null;
        this.right = null; 
    } 
}

public class BST {
	
	// Initially, root is null since tree is empty!
	Node root = null;
	
	/**
	 * Search if element x in BST (iteratively) 
	 * @param x (root of the tree)
	 * @param k (key)
	 * @return
	 */
	public boolean isElement(BST t, int k){
		Node x = t.root;
		
		while(!(x==null) && !(k==x.key)) {
			if(k < x.key) x = x.left;
			else x = x.right;
		}
		return (!(x == null));
		/*
	    // root null or the key is the root
	    if (x==null || k==x.key) return x;
	 
	    // Key less than root's key
	    if (k < x.key) return isElement(x.left, k);
	    // Key is greater than root's key
	    else return isElement(x.right, k);
	    */	    
	}
	
	/**
	 * Insert a new node z into an appropriate position in tree t
	 * O(log n)
	 * @param t (tree)
	 * @param z (the new node to be inserted)
	 */
	public void add(BST t, Node z) {
		Node y = null;
		Node x = t.root;
		
		while (!(x==null)) {
			y = x;
			if(z.key < x.key) x = x.left;
			else x = x.right;
		}
		
		if(y==null) t.root = z;
		else if(z.key < y.key) y.left = z;
		else y.right = z;
	}
	
	/**
	 * removes a given node from the BST
	 * O(log n)
	 * @param t
	 * @param z
	 * @return
	 */
	public Node remove(BST t, Node z) {
		
		Node parent = null;
		Node current = t.root;
		
		while(current != null && current.key != z.key) {
			parent = current;
			if(z.key < current.key) current = current.left;
			else current = current.right;
		}
		
		if(current == null) return t.root;
		
		// First case: node has no children
		if(current.left == null && current.right == null) {
			if(current!=t.root) {
				if(parent.left == current) parent.left = null;
				else parent.right = null;
			}else root=null;
		}
		// Second case: node has two children
		else if(current.left !=null && current.right != null) {
			while(current.right.left != null) {
				current.right = current.left;
			}
			
			int val = current.right.key;
			remove(t, current.right);
			current.key = val;
		}
		// Third case: node has one child
		else {
			Node child;
			if(current.left != null) child = current.left;
			else child = current.right;
			
			if (current != root) {
				if (current == parent.left) parent.left = child;
				else parent.right = child;
			}else t.root = child;
		}
		
		return t.root;
	}
	
	/**
	 * checks whether the tree s has no elements
	 * @param s 
	 * @return true if empty, false otherwise
	 */
	public boolean setEmpty(BST s) {
		if(s.root == null) return true;
		else return false;
	}
	
	/**
	 * returns the number of elements of set S
	 * @param s (tree)
	 * @return element of type int
	 */
	public int setSize(BST s) {
		return setSize(s.root);
	}
	private int setSize(Node t) {
		if(t == null) return 0;
		else return setSize(t.left) + 1 + setSize(t.right);
	}
	
	/**
	 * returns the union of sets S and T
	 * @param t (tree 1)
	 * @param s (tree 2)
	 */
	public void union(BST t, BST s) {
		BST tempTree = s;
		// call inOrder traversal for both trees (t and s)
		
		inOrder(t.root);
		inOrder(s.root);
	}
	
	public void intersection(Node p, Node q) {
	    if (p == null || q == null) return;

	    if (p.key < q.key) {
	    	System.out.println(p.key + "," + q.key);
	        intersection(p, q.left);
	        intersection(p.right, q);
	    } else if (p.key > q.key) {
	    	System.out.println(p.key + "," + q.key + ",2");
	        intersection(p.left, q);
	        intersection(p, q.right);
	    // There must be equal (intersection found)
	    } else {
	    	System.out.println(p.key + "," + q.key);
	        System.out.println("find " + p.key);
	        intersection(p.left, q.left);
	        intersection(p.right, q.right);
	    }
	}
	
	public boolean areIdentical(Node root1, Node root2)  
    { 
   
        /* base cases */
        if (root1 == null && root2 == null) 
            return true; 
   
        if (root1 == null || root2 == null) 
            return false; 
   
        /* Check if the data of both roots is same and data of left and right 
           subtrees are also same */
        return (root1.key == root2.key 
                && areIdentical(root1.left, root2.left) 
                && areIdentical(root1.right, root2.right)); 
    }
	
	
	public boolean isSubtree(Node T, Node S)  
    { 
        /* base cases */
        if (S == null)  
            return true; 
   
        if (T == null) 
            return false; 
   
        /* Check the tree with root as current node */
        if (areIdentical(T, S))  
            return true; 
   
        /* If the tree with root as current node doesn't match then 
           try left and right subtrees one by one */
        return isSubtree(T.left, S) 
                || isSubtree(T.right, S); 
    } 
	
	
	
	
	/**
	 * O(n)
	 * @param root
	 */
	public void inOrder(Node root) { 
	    if (root == null) 
	        return; 
	    else { 
	        inOrder(root.left); 
	        System.out.print(root.key +" ");
	        inOrder(root.right); 
	    } 
	} 
	
	
	
	public static void main(String[] args) {
		
		/*
		BST t = new BST();
		t.add(t, new Node(45));
        t.add(t, new Node(10)); 
        t.add(t, new Node(7)); 
        t.add(t, new Node(12)); 
        t.add(t, new Node(90)); 
        t.add(t, new Node(50));
        */
		BST t = new BST();
		t.add(t, new Node(10));
        t.add(t, new Node(4)); 
        t.add(t, new Node(6)); 
        t.add(t, new Node(30));
        
        BST s = new BST();
        s.add(s, new Node(26));
        s.add(s, new Node(3));
        s.add(s, new Node(4));
        s.add(s, new Node(10));
        s.add(s, new Node(6));
        s.add(s, new Node(30));
        /*
        BST s = new BST();
        s.add(s, new Node(50));
        s.add(s, new Node(30));
        s.add(s, new Node(20));
        s.add(s, new Node(40));
        s.add(s, new Node(70));
        s.add(s, new Node(60));
        s.add(s, new Node(12));
        */
        
        
        
        //System.out.println(t.setSize(t));
        // output the BST
        //System.out.println("The BST:"); 
        //t.inOrder(t.root);
        //System.out.println(t.isElement(t, 45));
        //t.remove(t, new Node(90));
        //System.out.println("The BST:"); 
        //t.inOrder(t.root);
        //System.out.println(t.isElement(t, 90));
        
        //t.union(t, s);
        t.inOrder(t.root);
        System.out.println();
        s.inOrder(s.root);
        System.out.println();
        t.intersection(t.root, s.root);
        System.out.println();
        System.out.println(t.isSubtree(t.root, s.root));
	}
	
	
}






/*
	public void add(BST S, int x) {
		// TODO
	}
	
	public void remove(BST s, int x) {
		// TODO
	}
	
	public void isElement(BST s, int x) {
		// TODO
	}
	
	public void setEmpty(BST s) {
		// TODO
	}
	
	public void setSize(BST s) {
		// TODO
	}
	*/









