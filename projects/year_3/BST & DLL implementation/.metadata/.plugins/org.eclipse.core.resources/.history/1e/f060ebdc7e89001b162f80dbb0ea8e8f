package DynamicSet;

import java.util.Arrays;

class Node { 
    
	Node left, right;
	int key; 
	
    public Node(int value){ 
        this.key = value; 
        this.left = null;
        this.right = null; 
    } 
}

public class BST {
	
	/** list of all nodes in the binary search tree */
	private int[] nodes;
	/** unique boolean field (for difference method) */
	boolean unique = true;
	
	// Initially, root is null since tree is empty!
	Node root = null;
	
	/**
	 * Search if element x in BST (iteratively) 
	 * @param x (root of the tree)
	 * @param k (key)
	 * @return
	 */
	public boolean isElement(BST t, int k){
		Node x = t.root;
		
		while(!(x==null) && !(k==x.key)) {
			if(k < x.key) x = x.left;
			else x = x.right;
		}
		return (!(x == null));
		/*
	    // root null or the key is the root
	    if (x==null || k==x.key) return x;
	 
	    // Key less than root's key
	    if (k < x.key) return isElement(x.left, k);
	    // Key is greater than root's key
	    else return isElement(x.right, k);
	    */	    
	}
	
	/**
	 * Inserts a new node z into an appropriate position in tree t
	 * O(log n)
	 * @param t (tree)
	 * @param z (the new node to be inserted)
	 */
	public void add(int x) {
		this.root = add(root, x);
	}
	private Node add(Node root, int x) {
		// Case 1: empty tree (the first element added is the root)
		if(root == null) {
			root = new Node(x);
			return root;
		}
		// Case 2: root.key < x (traverse and insert node right subtree)
		if(root.key < x) root.right = add(root.right, x);
		// Case 3: root.ley > x (traverse and insert node left subtree)
		else if(root.key > x) root.left = add(root.left, x);
		
		// return root when node inserted in correct position
		return root;
		
	}
	
	/**
	 * removes a given node from the BST
	 * O(log n)
	 * @param t
	 * @param z
	 * @return
	 */
	public Node remove(BST t, Node z) {
		
		Node parent = null;
		Node current = t.root;
		
		while(current != null && current.key != z.key) {
			parent = current;
			if(z.key < current.key) current = current.left;
			else current = current.right;
		}
		
		if(current == null) return t.root;
		
		// First case: node has no children
		if(current.left == null && current.right == null) {
			if(current!=t.root) {
				if(parent.left == current) parent.left = null;
				else parent.right = null;
			}else root=null;
		}
		// Second case: node has two children
		else if(current.left !=null && current.right != null) {
			while(current.right.left != null) {
				current.right = current.left;
			}
			
			int val = current.right.key;
			remove(t, current.right);
			current.key = val;
		}
		// Third case: node has one child
		else {
			Node child;
			if(current.left != null) child = current.left;
			else child = current.right;
			
			if (current != root) {
				if (current == parent.left) parent.left = child;
				else parent.right = child;
			}else t.root = child;
		}
		
		return t.root;
	}
	
	/**
	 * checks whether the tree s has no elements
	 * @param s 
	 * @return true if empty, false otherwise
	 */
	public boolean setEmpty(BST s) {
		if(s.root == null) return true;
		else return false;
	}
	
	/**
	 * returns the number of elements of set S
	 * @param s (tree)
	 * @return element of type int
	 */
	public int setSize(BST s) {
		return setSize(s.root);
	}
	private int setSize(Node t) {
		if(t == null) return 0;
		else return setSize(t.left) + 1 + setSize(t.right);
	}
	
	/**
	 * Creates an array containing the keys (inOrder) of all the nodes in the BST
	 * O(n)
	 */
	public int[] inOrderArrayTraversal(int[] nodes) {
		inOrderArrayTraversal(root, nodes, 0);
		return nodes;
	}
	private int inOrderArrayTraversal(Node root, int[] nodes, int curIndex) { 
	    if (root == null) return curIndex;
	    else { 
	    	curIndex = inOrderArrayTraversal(root.left, nodes, curIndex); 
	        nodes[curIndex++] = root.key;
	        curIndex = inOrderArrayTraversal(root.right, nodes, curIndex);
	        return curIndex;
	    } 
	} 
	
	/**
	 * returns the union of sets S and T
	 * O(n)
	 * @param t (tree 1)
	 * @param s (tree 2)
	 */
	public void union(BST t, BST s) {
		BST x = new BST();
		
		int[] arrayT = new int[t.setSize(t)];
		t.inOrderArrayTraversal(arrayT);
		int[] arrayS = new int[s.setSize(s)];
		s.inOrderArrayTraversal(arrayS);
		
		for(int i : arrayT) x.add(i);
		for(int j : arrayS) x.add(j);
		
		int[] temp = new int[t.setSize(t) + s.setSize(s)];
		System.out.println(Arrays.toString(x.inOrderArrayTraversal(temp)));
	}
	
	
	/**
	 * returns the union of two binary search trees
	 * O(n^2)
	 * @param t (tree 1)
	 * @param s (tree 2)
	 */
	public void intersection(BST t, BST s) {
	    BST x = new BST();
		
		int[] arrayT = new int[t.setSize(t)];
		t.inOrderArrayTraversal(arrayT);
		int[] arrayS = new int[s.setSize(s)];
		s.inOrderArrayTraversal(arrayS);
		
		for(int i : arrayT) {
			for(int j : arrayS) {
				if(i == j) x.add(i);
			}
		}
		
		int[] temp = new int[x.setSize(x)];
		
		System.out.println(Arrays.toString(x.inOrderArrayTraversal(temp)));
	}
	
	/**
	 * returns the difference of two binary search trees
	 * (set of nodes in s not present in t)
	 * O(n^2)
	 * @param t (tree 1)
	 * @param s (tree 2)
	 */
	public void difference(BST s, BST t) {
		BST x = new BST();
		
		int[] arrayT = new int[t.setSize(t)];
		t.inOrderArrayTraversal(arrayT);
		int[] arrayS = new int[s.setSize(s)];
		s.inOrderArrayTraversal(arrayS);
		
		
		for(int i : arrayT) {
			for(int j : arrayS) {
				if(i == j) unique = false;
			}
			if(unique==true) x.add(i);
		}
		
		int[] temp = new int[x.setSize(x)];
		System.out.println(Arrays.toString(x.inOrderArrayTraversal(temp)));
		
	}
	
	/**
	 * Helper method to find if two binary search trees are identical.
	 * O(n)
	 * @param x
	 * @param y
	 */
	private final boolean identical(Node x, Node y) {
		// Case 1: empty nodes
		if(x == null && y == null) return true;
		if((x != null && y != null) && (x.key == y.key)) {
			return identical(x.left, y.left) && identical(x.right, y.right);
		}
		
		return false;
	}
	
	/**
	 * Helper method to find if array A is a sub-array of array B
	 * @param A (array - check if sub-array)
	 * @param B (array)
	 * @param n (length of array A)
	 * @param m (length of array B)
	 * @return
	 */
    private boolean isSubarray(int A[], int B[],  int n, int m) { 
        // Two pointers to traverse each respective array
        int i = 0, j = 0; 
      
        while (i < n && j < m) { 
            if (A[i] == B[j]) { 
                i++; 
                j++; 
                // If array B has all elements in arrayA
                if (j == m) return true; 
            } else{ 
            	j = 0; 
                //i = i - j + 1;
            	i++;
            } 
        }
        // Array A is not a sub array of Array B
        return false; 
    } 
    
	/**
	 * checks whether a binary search tree is a subset of another binary search tree
	 * O(n)
	 * @param s (tree 1)
	 * @param t (tree 2)
	 */
	public boolean subset(BST s, BST t) {
		int[] arrayT = new int[t.setSize(t)];
		t.inOrderArrayTraversal(arrayT);
		int[] arrayS = new int[s.setSize(s)];
		s.inOrderArrayTraversal(arrayS);
		
		return isSubarray(arrayT, arrayS, arrayT.length, arrayS.length);
	}
	
	
	
	
	
	public static void main(String[] args) {
		
		/*
		BST t = new BST();
		t.add(t, new Node(45));
        t.add(t, new Node(10)); 
        t.add(t, new Node(7)); 
        t.add(t, new Node(12)); 
        t.add(t, new Node(90)); 
        t.add(t, new Node(50));
        */
		BST t = new BST();
		Node a = new Node(10);
		Node b = new Node(4);
		Node c = new Node(6);
		Node d = new Node(30);
		
		t.add(12);
        t.add(4); 
        t.add(6); 
        t.add(30);
        
        int[] array = new int[t.setSize(t)];
        
        System.out.println(Arrays.toString(t.inOrderArrayTraversal(array)));
        
        //t.remove(t, a);
        
        BST s = new BST();
        s.add(50);
        s.add(30);
        s.add(20);
        s.add(40);
        s.add(70);
        s.add(60);
        s.add(12);
        
        array = new int[s.setSize(s)];
        System.out.println(Arrays.toString(s.inOrderArrayTraversal(array)));
        System.out.println();
        
        t.union(t, s);
        System.out.println();
        t.intersection(t, s);
        System.out.println();
        t.difference(s, t);
        System.out.println();
        System.out.println(t.subset(t,s));
        System.out.println();
	}
	
	
}
