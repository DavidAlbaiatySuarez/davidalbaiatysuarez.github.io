package DynamicSet;

import java.util.Arrays;

class Node { 
    
	Node left, right;
	int key; 
	
    public Node(int value){ 
        this.key = value; 
        this.left = null;
        this.right = null; 
    } 
}

public class BST {
	
	/** list of all nodes in the binary search tree */
	private int[] nodes;
	
	// Initially, root is null since tree is empty!
	Node root = null;
	
	/**
	 * Search if element x in BST (iteratively) 
	 * @param x (root of the tree)
	 * @param k (key)
	 * @return
	 */
	public boolean isElement(BST t, int k){
		Node x = t.root;
		
		while(!(x==null) && !(k==x.key)) {
			if(k < x.key) x = x.left;
			else x = x.right;
		}
		return (!(x == null));
		/*
	    // root null or the key is the root
	    if (x==null || k==x.key) return x;
	 
	    // Key less than root's key
	    if (k < x.key) return isElement(x.left, k);
	    // Key is greater than root's key
	    else return isElement(x.right, k);
	    */	    
	}
	
	/**
	 * Inserts a new node z into an appropriate position in tree t
	 * O(log n)
	 * @param t (tree)
	 * @param z (the new node to be inserted)
	 */
	public void add(int x) {
		this.root = add(root, x);
	}
	private Node add(Node root, int x) {
		// Case 1: empty tree (the first element added is the root)
		if(root == null) {
			root = new Node(x);
			return root;
		}
		// Case 2: root.key < x (traverse and insert node right subtree)
		if(root.key < x) root.right = add(root.right, x);
		// Case 3: root.ley > x (traverse and insert node left subtree)
		else if(root.key > x) root.left = add(root.left, x);
		
		// return root when node inserted in correct position
		return root;
		
	}
	
	/**
	 * removes a given node from the BST
	 * O(log n)
	 * @param t
	 * @param z
	 * @return
	 */
	public Node remove(BST t, Node z) {
		
		Node parent = null;
		Node current = t.root;
		
		while(current != null && current.key != z.key) {
			parent = current;
			if(z.key < current.key) current = current.left;
			else current = current.right;
		}
		
		if(current == null) return t.root;
		
		// First case: node has no children
		if(current.left == null && current.right == null) {
			if(current!=t.root) {
				if(parent.left == current) parent.left = null;
				else parent.right = null;
			}else root=null;
		}
		// Second case: node has two children
		else if(current.left !=null && current.right != null) {
			while(current.right.left != null) {
				current.right = current.left;
			}
			
			int val = current.right.key;
			remove(t, current.right);
			current.key = val;
		}
		// Third case: node has one child
		else {
			Node child;
			if(current.left != null) child = current.left;
			else child = current.right;
			
			if (current != root) {
				if (current == parent.left) parent.left = child;
				else parent.right = child;
			}else t.root = child;
		}
		
		return t.root;
	}
	
	/**
	 * checks whether the tree s has no elements
	 * @param s 
	 * @return true if empty, false otherwise
	 */
	public boolean setEmpty(BST s) {
		if(s.root == null) return true;
		else return false;
	}
	
	/**
	 * returns the number of elements of set S
	 * @param s (tree)
	 * @return element of type int
	 */
	public int setSize(BST s) {
		return setSize(s.root);
	}
	private int setSize(Node t) {
		if(t == null) return 0;
		else return setSize(t.left) + 1 + setSize(t.right);
	}
	
	/**
	 * O(n)
	 * @param root
	 */
	public void inOrder(Node root) { 
	    if (root == null) return;
	    else { 
	    	inOrder(root.left); 
	        System.out.print(root.key +" ");
	        //nodes.add(root.key);
	        inOrder(root.right); 
	    } 
	} 
	
	/**
	 * returns the union of sets S and T
	 * @param t (tree 1)
	 * @param s (tree 2)
	 */
	public void union(BST t, BST s) {
		BST x = new BST();
		
		for(int i=0;i<t.setSize(t);i++) {
			if (root == null) return;
		    else { 
		    	inOrder(root.left); 
		        //System.out.print(root.key +" ");
		        nodes[i] = root.key;
		        inOrder(root.right); 
		    }
		}
		
		// System.out.println(Arrays.toString(nodes));
		
		
		
		//inOrder(tempTree.root);
	}
	
	public void intersection(Node p, Node q) {
	    if (p == null || q == null) return;

	    if (p.key < q.key) {
	    	System.out.println(p.key + "," + q.key);
	        intersection(p, q.left);
	        intersection(p.right, q);
	    } else if (p.key > q.key) {
	    	System.out.println(p.key + "," + q.key + ",2");
	        intersection(p.left, q);
	        intersection(p, q.right);
	    // There must be equal (intersection found)
	    } else {
	    	System.out.println(p.key + "," + q.key);
	        System.out.println("find " + p.key);
	        intersection(p.left, q.left);
	        intersection(p.right, q.right);
	    }
	}
	
	public boolean areIdentical(Node root1, Node root2)  
    { 
   
        /* base cases */
        if (root1 == null && root2 == null) 
            return true; 
   
        if (root1 == null || root2 == null) 
            return false; 
   
        /* Check if the data of both roots is same and data of left and right 
           subtrees are also same */
        return (root1.key == root2.key 
                && areIdentical(root1.left, root2.left) 
                && areIdentical(root1.right, root2.right)); 
    }
	
	
	public boolean isSubtree(Node T, Node S)  
    { 
        /* base cases */
        if (S == null)  
            return true; 
   
        if (T == null) 
            return false; 
   
        /* Check the tree with root as current node */
        if (areIdentical(T, S))  
            return true; 
   
        /* If the tree with root as current node doesn't match then 
           try left and right subtrees one by one */
        return isSubtree(T.left, S) 
                || isSubtree(T.right, S); 
    } 
	
	
	
	
	
	
	
	
	public static void main(String[] args) {
		
		/*
		BST t = new BST();
		t.add(t, new Node(45));
        t.add(t, new Node(10)); 
        t.add(t, new Node(7)); 
        t.add(t, new Node(12)); 
        t.add(t, new Node(90)); 
        t.add(t, new Node(50));
        */
		BST t = new BST();
		Node a = new Node(10);
		Node b = new Node(4);
		Node c = new Node(6);
		Node d = new Node(30);
		
		t.add(10);
        t.add(4); 
        t.add(6); 
        t.add(30);
        
        t.inOrder(t.root);
        
        //t.remove(t, a);
        
        /*
        BST s = new BST();
        s.add(s, new Node(26));
        s.add(s, new Node(3));
        s.add(s, new Node(4));
        s.add(s, new Node(10));
        s.add(s, new Node(6));
        s.add(s, new Node(30));
        */
        //System.out.println(Arrays.toString(s.nodes));
        
        BST s = new BST();
        s.add(50);
        s.add(30);
        s.add(20);
        s.add(40);
        s.add(70);
        s.add(60);
        s.add(12);
        
        
        
        //System.out.println(t.setSize(t));
        // output the BST
        //System.out.println("The BST:"); 
        //t.inOrder(t.root);
        //System.out.println(t.isElement(t, 45));
        //t.remove(t, new Node(90));
        //System.out.println("The BST:"); 
        //t.inOrder(t.root);
        //System.out.println(t.isElement(t, 90));
        
        t.union(t, s);
        //t.inOrder(t.root);
        //System.out.println();
        //s.inOrder(s.root);
        //System.out.println();
        //t.intersection(t.root, s.root);
        //System.out.println();
        //System.out.println(t.isSubtree(s.root, t.root));
	}
	
	
}
